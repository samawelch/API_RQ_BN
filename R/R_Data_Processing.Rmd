---
title: "Tiered Bayesian Risk Assessment of Estrogen Mixtures"
output: html_notebook
---

# Packages

```{r packages, warning=FALSE}
library(tidyverse)
library(lme4)
library(readxl)
library(drc)
library(TTR)
library(forecast)
library(sjPlot)
```

# Input

```{r data_input, warning=FALSE}
# Task: Load in NIPH data back to 199-whenever
getwd()
NIPH_Sales_Weights <- read_excel(path = "Data/NIPH_DB/t830_Product_API_sold_per_year_20220629.xlsx")

# Immediately shortlist to interesting APIs to save time later
Interesting_APIs <- c("estradiol", "ethinylestradiol", "levonorgestrel", "diclofenac", 
                      "ibuprofen", "paracetamol", "ciprofloxacin", "amoxicillin")

NIPH_Sales_Weights <- NIPH_Sales_Weights %>% filter(API_Name %in% Interesting_APIs)

# To calculate historic PECs, we'll need historic population and WW production figures

# mainland Norwegian population on 1 Jan per year 1951 - 2021
# accessed from https://data.ssb.no/api/v0/en/table/06913/
# 15:57 12/05/2021

Norway_Population_Year <- read_xlsx(path = "Data/Statistics_Norway/Pop_1951_2021.xlsx",
                                    range = "B4:C74",
                                    col_names = c("Year", "Population")) %>% 
  mutate(Year = as.numeric(Year))

# wastewater consumption per person per day in Norway 2015 - 2020 (SSB)
# accessed from https://data.ssb.no/api/v0/en/table/11787/
# 14:49 12/05/2021

Norway_Wastewater_Year <- read_xlsx(path = "Data/Statistics_Norway/WW_per_PD_2015_2020.xlsx",
                                    range = "B4:G5") %>% 
  # Pivot into long data
  pivot_longer(cols = 1:6,
               names_to = "Year",
               values_to = "L_per_person_per_day") %>% 
  # Make sure Year is numeric so it doesn't break everything
  mutate(Year = as.numeric(Year)) %>% 
# Obviously this doesn't go back far enough, so we'll backfill it to 1999 with fake data
  add_row(Year = 1999:2014, L_per_person_per_day = 180)
  
# Norwegian Population Predictions from SSB (No Uncertainty Included)
Norway_Population_Projections_21C <- read_xlsx(path = "Data/Statistics_Norway/Pop_Forecasts_21C.xlsx",
                                               range = "B4:J7") %>% 
  rename("Scenario" = `...1`) %>% 
  pivot_longer(cols = 2:9,
               names_to = "Year",
               values_to = "Population") %>% 
  mutate(Year = as.double(Year))

# PNECs for our interesting APIs
API_PNECs <- read.csv(file = "Data/APIs_PBMT_byYear_2022-09-01_12.12.csv") %>% 
  dplyr::select(API_Name, PNEC_gL) %>% 
  filter(API_Name %in% Interesting_APIs) %>% 
  distinct()

```

# Dataset Summary

```{r add_APIs}
NIPH_Sales_Weights_Summed <- NIPH_Sales_Weights %>% 
  group_by(API_Name, sYear) %>% 
  summarise(Total_Sold_g = sum(API_AmountSoldValue, na.rm = TRUE))

ggplot(data = NIPH_Sales_Weights_Summed, 
       mapping = aes(x = sYear, y = Total_Sold_g, colour = API_Name)) +
  geom_line() +
  scale_y_continuous(trans = "log10")
```

```{r API_sales_by_population}
API_sales_by_population <- 
  NIPH_Sales_Weights_Summed %>% left_join(y = Norway_Population_Year, by = c("sYear" = "Year"))

ggplot(data = API_sales_by_population, mapping = 
         aes(x = Population, 
             y = Total_Sold_g,
             colour = API_Name)) + 
  geom_point() +
  geom_smooth(method = "lm") 

# Calculate a linear relationship between sales and population
# Sales_over_Pop <- lm(Total_Sold_g ~  API_Name:Population, data = API_sales_by_population) %>% 
# coef() %>% 
#   as.list() %>% 
#   as.tibble() %>% 
#   pivot_longer(cols = 2:9) %>% 
#   transmute(API_Name = str_remove_all(string = name, pattern = "(API_Name)|(:Population)"),
#             Sales_over_Pop_g = value)

# Pretty sure the above lm sucked, so let's try running individual LMs
LMs_API <- API_sales_by_population %>% 
  group_by(API_Name) %>% 
  summarise(lm_intercept = coef(lm(Total_Sold_g ~ Population))[[1]],
            lm_coef = coef(lm(Total_Sold_g ~ Population))[[2]])

ggplot(data = Norway_Population_Projections_21C, mapping = aes(
  x = Year,
  y = Population,
  colour = Scenario,
  group = Scenario)) +
  geom_point() +
  geom_path()

# Run some examples and see how it looks graphed
Sales_Projections_21C <- 
  crossing(LMs_API, Norway_Population_Projections_21C) %>% 
  mutate(Sales_Proj_g = Population * lm_coef + lm_intercept) %>% 
# Pick some APIs
  filter(API_Name %in% c("paracetamol", "ethinylestradiol"))

# Join projections and records together to plot on one graph
Sales_Projections_Records <- Sales_Projections_21C %>% 
  transmute(API_Name,
            Total_Sold_g = Sales_Proj_g, 
            sYear = Year, 
            Scenario) %>% 
  add_row(NIPH_Sales_Weights_Summed %>% transmute(API_Name,
                                                  sYear,
                                                  Total_Sold_g,
                                                  Scenario = "Measured")) %>% 
    filter(API_Name %in% c("paracetamol", "ethinylestradiol"))

ggplot(data = Sales_Projections_Records,
       mapping = aes(x = sYear, 
                     y = Total_Sold_g,
                     colour = API_Name,
                     shape = Scenario)) + 
  geom_point()
```

```{r checks}
# TODO: Finish & generalise this
# Some comparisons between calculations in Hugin and here
# We'll compare paracetamol in 2018 here and 2020 in the BN
Paracetamol_Projections_21C <- Sales_Projections_Records %>% 
  filter(API_Name == "paracetamol") %>% 
  left_join(Norway_Population_Projections_21C, by = c("Scenario", "sYear" = "Year"))
```


```{r Hugin_Data_Maker}
# Make data files for automated data input/output to Hugin
Hugin_Data_File <- LMs_API %>% 
  left_join(API_PNECs, by = "API_Name") %>% 
  transmute(API_Name,
            API_LM_Coeff = lm_coef,
            API_LM_Interc = lm_intercept,
            API_PNEC_gL = PNEC_gL) %>% 
  # Use vector recycling via crossing to set up the various scenario combinations easily
  crossing(Population_Scenario = as_factor(c("Low", "Main", "High")),
           Year = c("2020", "2030", "2040", "2050", "2060", "2070", "2080", "2090", "2100"),
           WWTP_Removal_Scenario = c("0-0.25", "0.25-0.5", "0.5-0.75", "0.75-1")) %>% 
  add_column(`[MEAN](Norway_Population_mil)` = NA, 
             `[MEAN](API_Sales_Weight_kg)` = NA, 
             `[MEAN](Water_Consumption_ML)` = NA,
             `[MEAN](PEC_Inf_gL)` = NA, 
             `[MEAN](PEC_Eff_gL)` = NA, 
             `[MEAN](PEC_SW_gL)` = NA,
             `[MEAN](RQ)` = NA,
             `P(RQ=0-0.01)` = NA,
             `P(RQ=0.01-0.1)` = NA,
             `P(RQ=0.1-1)` = NA,
             `P(RQ=1-10)` = NA,
             `P(RQ=10-100)` = NA,
             `P(RQ=100-1000)` = NA,
             `P(RQ=1000-10000)` = NA,
             `P(RQ=10000-100000)` = NA,             
             `P(RQ=100000-inf)` = NA)

write_csv(x = Hugin_Data_File, file = "Data/Hugin/R_to_Hugin_datafile.csv", na = "")
```

```{r Hugin_Data_Reader}
# Hugin has done its thing, so let's import the data
Hugin_Data_Output <- read_csv(file = "Data/Hugin/Hugin_API_Output.csv",
                              show_col_types = FALSE) %>% 
  # rename_with(cols = 8:15, ~str_remove(string = ., pattern = "\\[MEAN\\]")) %>% 
  # rename_with(cols = 8:15, ~str_remove_all(string = ., pattern = "\\W"))
# Need to refactorise population scenarios
  mutate(Population_Scenario = fct_relevel(Population_Scenario, c("Low", "Main", "High")),
         WWTP_Removal_Scenario = fct_rev(WWTP_Removal_Scenario))
```

```{r Some_Graphs}
# I'm gonna make some graphs!
# Sales Weight, by year, scenario & API
ggplot(data = Hugin_Data_Output,
       mapping = aes(x = Year,
                     y = `[MEAN](API_Sales_Weight_kg)`,
                     colour = Population_Scenario,
                     shape = Population_Scenario)) +
  geom_point() +
  geom_path() +
  facet_wrap(facets = vars(API_Name), ncol = 4, scales = "free") +
  scale_color_discrete(breaks = c("Low", "Main", "High")) +
  scale_shape_discrete(breaks = c("Low", "Main", "High"))

# What's going on with these APIs?
Diclofenac_Weird <- Hugin_Data_Output %>% 
  filter(API_Name == "diclofenac",
         WWTP_Removal_Scenario == "0 - 0.001") %>% 
  dplyr::select(API_Name, Year, `[MEAN](API_Sales_Weight_kg)`, Population_Scenario) %>% 
  distinct()

# Various PECs
ggplot(data = Hugin_Data_Output,
       mapping = aes(x = Year,
                     y = `[MEAN](PEC_Inf_gL)`,
                     colour = Population_Scenario,
                     shape = Population_Scenario)) +
  geom_point() +
  geom_path() +
  facet_wrap(facets = vars(API_Name), ncol = 4, scales = "free") +
  scale_color_discrete(breaks = c("Low", "Main", "High")) +
  scale_shape_discrete(breaks = c("Low", "Main", "High"))

# RQ by year, scenario & API
ggplot(data = Hugin_Data_Output,
       mapping = aes(x = Year,
                     y = `[MEAN](RQ)`,
                     colour = WWTP_Removal_Scenario,
                     shape = Population_Scenario)) +
  geom_point() +
  geom_path() +
  facet_wrap(facets = vars(API_Name), ncol = 4) +
  scale_color_discrete(breaks = c("Low", "Main", "High")) +
  scale_shape_discrete(breaks = c("Low", "Main", "High"))

# Now we're gonna try and make some graphs like Sophie's!
Sophie_Graph_Data <- Hugin_Data_Output %>% 
  filter(API_Name == "levonorgestrel") %>% 
  dplyr::select(1, 5:7, 15:23) %>% 
  pivot_longer(cols = 5:13,
               names_to = "RQ_Bin",
               values_to = "Probability")

# Set up some custom labels for a slightly more sense-making facet
Sophie_Graph_Labeller = c("0-0.25" = "Primary: 0 - 0.25", "0.25-0.5" = "Secondary: 0.25 - 0.5", 
                          "0.5-0.75" = "Tertiary: 0.5 - 0.75", "0.75-1" = "Advanced: 0.75 - 1",
                          "High" = "High Growth Population", 
                          "Main" = "Main Growth Population",
                          "Low" = "Low Growth Population")
# Doesn't work right now, will troubleshoot some other time

ggplot(data = Sophie_Graph_Data, 
       mapping = aes(x = Year,
                     y = Probability,
                     fill = RQ_Bin)) +
  geom_col(position = position_fill(reverse = TRUE)) +
  facet_grid(rows = vars(Population_Scenario),
             cols = vars(WWTP_Removal_Scenario)) +
  scale_fill_viridis_d(option = "plasma", direction = 1)

```